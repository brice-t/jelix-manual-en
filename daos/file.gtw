~~LANG:FR@frman:daos/fichier_de_base~~

In order to use jDao, you have to write an XML file which describes the mapping, i.e, which properties of a jDao record correspond to which field in a SQL table.


===== Creating a file automatically =====

A DAO file can be generated by the jelix script on the command line, from an existing table.

<code bash>
 php jelix.php --my_application createdao modulename daoname tablename
</code>

For example, if you want to create a "product" dao from the table "shop_product" in the "myshop" module, you will enter:

<code bash>
 php jelix.php --my_application createdao myshop product shop_product
</code>

In the @@F@daos@@ directory of the //myshop// module, you will have then a  @@F@product.dao.xml@@ file which contain the mapping description.

The automatic generation of a dao file helps to create quickly, but you will have often to modify this files to customize the mapping, to add method declaration etc..

===== Details on the XML format =====

<code xml>
<dao xmlns="http://jelix.org/ns/dao/1.0">
   <datasources>
     datasources section
   </datasources>
   <record>
      properties section
   </record>
   <factory>
      methods section
   </factory>
</dao>
</code>

There are three sections, although the @@E@<factory>@@ section is optional. This section is described [[xml_methods|in an other page]].

  * @@E@<datasources>@@ : defines the tables on which the object will be mapped.
  * @@E@<record>@@ : defines the mapping itself.

===== Simple mapping =====

==== Table declaration ==== 

We call simple mapping, a mapping where a record = a table. To declare the table, we use the tag @@E@<primarytable>@@ with the following attributes:

   * @@A@name@@: alias given to the table and that will be used in queries
   * @@A@realname@@ (optional): real name of the table in the database. If this attribute is not specified, it takes the same value as the attribute @@A@name@@. In this case @@A@name@@ must contain the real name of the table.
   * @@A@primarykey@@ indicates the primary key. You can specify multiple keys, separated by a space or a comma.


<code xml>
  <datasources>
      <primarytable name="p" realname="products" primarykey="id_product" />
  </datasources>
</code>


It says here that the record will be based on the table @@products@@, which has the alias @@p@@, and which contains the primary key @@id_product@@.

There is always a single table "primary" in a DAO (hence a single tag @@E@<primarytable>@@). You will see that you can specify other tables (foreign tables) farther.

Then we should declare the mapping between the record fields and the object properties.




==== Properties declaration ====

The @@E@<record>@@ section declares the properties of an object @@record@@. Each property corresponds to a field in the primary table, or one of those foreign tables as you will see later. Of course, you are not obliged to declare a property for all existing fields. We can make several DAO working on the same table but which are intended for different uses. For example make a specific DAO to recover slight registration lists (so the mapping is made on the essential properties), and an other to manage full datas (so the mapping is made on all fields).

The @@E@<record>@@ section  must contain one or more @@E@<property>@@ element:


<code xml>
  <property 
      name="simplificated name" 
      fieldname="filed name" 
      datatype="" required="true/false" minlength="" maxlength="" regexp="" 
      sequence="sequence name"
      updatepattern="" insertpattern="" selectpattern=""
      default="" 
   />
</code>

The attribute @@A@name@@ is the name of the property of the object.

The attribute @@A@fieldname@@ is the field name on which the property is mapped. If @@A@name@@ and @@A@fieldname@@ are equals, we can leave @@A@fieldname@@.

The attributes @@A@datatype@@, @@A@required@@, @@A@minlength@@, @@A@maxlength@@ and @@A@regexp@@ are constraints. This allows the @@M@check()@@ method to verify the values of properties (before storage for instance).

The attribute @@A@default@@ (since jelix 1.0RC1) allows you to specify a default value which will be stored in the property.

The attribute @@A@datatype@@ can be set to:
   * @@string@@
   * @@int@@
   * @@integer@@
   * @@autoincrement@@
   * @@double@@ / @@float@@
   * @@numeric@@ / @@bigautoincrement@@
   * @@date@@
   * @@time@@
   * @@datetime@@
   * @@boolean@@
   * @@varbinary@@ (since jelix 1.1.6)

On some databases, an autoincrement field can be associated with a sequence. Then the attribute @@A@sequence@@ should contain the sequence name.

The attributes @@A@updatepattern@@, @@A@insertpattern@@ and @@A@selectpattern@@ lets you specify a pattern to be applied during the update, the insert or the read of the field value. This pattern should really be a SQL expression, and can contain the string "%s", which will be replaced by the value or the name of the field. Default values of patterns is "%s". If it indicates an empty value, this corresponds to a null operation (so the field is not readed, inserted or updated).

=== Example 1 ===

For a field which contains an updated date, we can do:

<code xml>
  <property name="date_update" datatype="datetime" insertpattern="NOW()" updatepattern="NOW()" />
</code>

So each time there is an insert or an update, the inserted value will be the current date.


=== Example 2 ===

It may also have a property that does not correspond directly to a field, but that is the result of a SQL expression. In this case, you must disable the inserting and updating.

<code Xml>
   <property Name="identite" datatype="string" selectpattern="CONCAT(name,' ',firstname)" insertpattern="" updatepattern="" />
</code>

Carefull about the content of @@A@selectpattern@@:

  * Expression must use fields of a single table. If a dao is based on multiple tables (for example, A and B, see next section), it is not possible to indicate both fields from the  table A and the table B in the same @@A@selectpattern@@.
  * If the expression uses some fields of the table B (a foreign table), then corresponding properties should be declared for this table, with the @@A@table@@ attribute on the @@E@<property>@@ element, with the  name or alias of the table B, as a value.


===== Mapping on several tables =====

We can declare a table, but also additionnal tables which are linked to the main table by joins. It is useful when you want to retrieve simultaneously a record and informations of other tables. For example, if you want to retrieve a product of the "products" table, and at the same time the name of its category from the table "category", you should also declared the table "category". Note that you can modify only data which come from the main table when you want to update or insert a record.

To declare such foreign tables, which are logically related to the main table by foreign keys, you should use:
   * @@E@<foreigntable>@@ to indicate a foreign table  linked by a normal join.
   * @@E@<optionalforeigntable>@@ to indicate a foreign table linked by an outer join.

=== Example ===

<code xml>
   <primarytable name="p" realname="products" primarykey="id_product" />
   <foreigntable name="cat" realname="categories" primarykey="id_cat" onforeignkey="id_cat" />
   <optionalforeigntable name="man" realname="manufacturers" primarykey="id" onforeignkey="id_manufacturer" />
</code>

As for tag @@E@<primarytable>@@, there are attributes @@A@name@@, @@A@realname@@ and @@A@primarykey@@. There is also an additional attribute, @@A@<onforeignkey>@@, which indicates the name of the field in the primary table, which is the foreign key on the table in question. Thus, with the above example, jDao generate requests for type @@SELECT@@ terms @@FROM@@ and @@WHERE@@:

<code sql>
 FROM products as p left join manufacturers as man on (p.id_manufacturer = man.id),  categories as cat
 WHERE cat.id_cat = p.id_cat
</code>


You can add @@E@<property>@@ element to map properties to field of foreign tables, like any other property for the main table. The only difference is that you have to add an attribute @@A@table@@ which indicates the alias of the table in which the field belongs to.

<code xml>
  <property 
      name="category_label" 
      fieldname="label" 
      table="cat"
   />
</code>

