~~LANG:FR@frman:classes-metiers~~

To respect the MVC pattern, it is recommended to do all business processing and services in classes dedicated to it instead of in controllers.

In this kind of classes, you will manipulate, for example, daos, data from daos or others, do all the processing other than display. The methods of your controllers will thus be lighter and the business processing will be reusable in other actions.


===== Creating a class =====

Business classes and services in Jelix are classic PHP classes which have nothing specific. The only thing that you have to respect is to specify it in a file named @@F@name_of_class.class.php@@ in the @@F@classes/@@ directory of the module, so it can be loaded by @@C@jClasses@@:

<code php>  
   class StockService {
      public function getProductsList(){
          $stock = jDAO::get("products");
          
          $list = $stock->findAll();
          
          // here : processing of the list (for example)
          
          return $list;      
      }
   }
</code>

This class must be placed in @@F@classes/StockService.class.php@@.

The difference between a service class and the other classes is that a service class gives... a service. It doesn't need to be instanciated each time we use it because it doesn't have "discriminating" property. Only one instance is enough for all the application.

For example, a "factory" type class, which retrieves sets of data, is a service class. On the other hand, a class representing a product, which thus has identifying fields, is a non service class.


===== Instantiation with jClasses =====

Jelix proposes the @@C@jClasses@@ class, which avoids to do an include and instantiate yourself.

@@C@jClasses@@ gives two static methods, to which you give a selector:

    * @@M@createInstance($ClassSelector)@@ (or @@M@create($ClassSelector)@@ )
    * @@M@getService($ClassSelector)@@

The first will, for each call, give a new instance. The second will allways give the same instance of the class. @@M@getService@@ will thus be used for the service classes, and @@M@createInstance@@ for the others.

If our @@C@StockService@@ class is in the "shop" module, here is an example in a controller:

<code php>
    $stocksrv = jClasses::getService("shop~stockservice");
    $rep->body->assign('product_list', $stocksrv->getProductList());
</code>

Notice that you can put classes in sub-directories of the @@F@classes/@@ directory. For example, you can store the @@C@StockService@@ file into @@F@classes/stocks/@@. Then, to call it:

<code php>
   $stocksrv = jClasses::getService("shop~stocks/stockservice");
</code>

===== Including classes =====

In some cases, like when the constructor needs parameters, you have to include the class and then instantiate it "manually".

In this case the jClasses class has a static method @@M@inc($ClassSelector)@@. It includes (require_once) the class specified by the selector.

Example:
<code php>
    jClasses::inc('shop~shoesProduct');
    $shoe = new shoesProduct('43', 'black');
</code>

===== Including interfaces =====

@@C@jClasses@@ provides the static methods @@M@incIFace@@ to include PHP interfaces stored in a @@F@classes@@ directory of a module.

An interface should be store in a @@F@*.iface.php@@ file. To declare a @@C@IStockUtils@@ interface, store this content into the file @@F@classes/interfaces/IStockUtils.iface.php@@:

<code php><?php
interface IStockUtils {
    […]
}
?></code>

Then to include this interface, stored in the module @@commons@@, into file that need it:

<code php><?php
jClasses::inIface('commons~interfaces/IStockUtils');

class stockUtils implements IStockUtils {
    […]
}
?></code>


===== Installing and using vendor classes =====

You have often to use some classes provided by other projects. Of course, you can use it into a Jelix application.

Although you can store this classes where you want (because the require or include statement are not restricted), it's better to store them:

  * into the @@F@lib/@@ directory
  * or into the @@F@classes/@@ directory of a module

It is interesting to store a set of classes into the @@F@lib/@@ directory, because it's easier to share this classes between projects, and perhaps it will be easier to update them. To include them, you have to use the @@LIB_PATH@@ constant. For example, if you want to include the @@F@lib/foo/bar.php@@, do this into your controller or other files of a module:

<code php>
   require(LIB_PATH.'foo/bar.php');
   $myclass = new bar();
</code>

You can store the class in a module if it is used only by this module. You can put it into the classes directory:

<code php>
   require($GLOBALS['gJCoord']->getModulePath('main') . 'classes/bar.php');
   $myclass = new bar();
</code>

If the name of the class and the name of the file follow the coding style of jelix (a "bar" class into a bar.class.php file), you can use jClasses of course:

<code php>
   $myclass = jClasses::create('bar');

   // or if the constructor need arguments
   jClasses::inc('bar');
   $myclass = new bar('bla');
</code>

===== Loading classes before the session_start =====

Sometimes, you may want to store some of your business object in sessions. But then your classes should be loaded before the @@f@session_start()@@ call, so PHP can unserialize this objects.

Jelix provide a simple way to indicates which classes to load before the @@f@session_start()@@. In the configuration, in the @@sessions@@ section, indicate the selectors of this classes in the @@V@loadClasses@@ options:

<code ini>
[sessions]

loadClasses = "mymodule~bar,mymodule~subdir/foo, shop~shoesProduct"
</code>

Note: the module name is required.
